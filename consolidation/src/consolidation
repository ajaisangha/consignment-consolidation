// capacity per section per consignment
const SECTION_CAPACITY = 40; // ambient 40, chill 40

/**
 * consignment shape:
 * {
 *   id: string,
 *   ambientTotes: number,
 *   chillTotes: number
 * }
 *
 * returns:
 * {
 *   consignments: Array<{id, ambientTotes, chillTotes}> // after consolidation, max 9
 *   moves: Array<{fromId, toId, section, amount}>
 * }
 */
export function consolidateConsignmentsForShipment(consignments) {
  // Deep clone so we don't mutate the original list
  let list = consignments.map((c) => ({
    id: c.id,
    ambientTotes: c.ambientTotes || 0,
    chillTotes: c.chillTotes || 0
  }));

  const moves = [];

  // Helper to compute free space for one consignment/section
  const freeSpace = (c, section) => {
    const used = section === "ambient" ? c.ambientTotes : c.chillTotes;
    return Math.max(0, SECTION_CAPACITY - used);
  };

  // Keep consolidating until <= 9 consignments or no more moves possible
  let changed = true;
  while (list.length > 9 && changed) {
    changed = false;

    // Sort by lightest: ambient first, then chill
    list.sort((a, b) => {
      if (a.ambientTotes !== b.ambientTotes) {
        return a.ambientTotes - b.ambientTotes;
      }
      return a.chillTotes - b.chillTotes;
    });

    // Try to eliminate the lightest consignment
    const from = list[0];
    if (!from) break;

    // Function to move totes for a single section
    const moveSection = (section) => {
      let remaining =
        section === "ambient" ? from.ambientTotes : from.chillTotes;
      if (remaining <= 0) return;

      // 1) Try same section in other consignments
      const tryMove = (preferSameSection) => {
        let movedSomething = false;

        // For every potential receiver
        while (remaining > 0) {
          // Find best receiver: enough free space with minimal leftover
          let best = null;
          let bestFreeAfter = Infinity;

          list.forEach((c) => {
            if (c.id === from.id) return;

            const sameSectionFree = freeSpace(c, section);
            const otherSection =
              section === "ambient" ? "chill" : "ambient";
            const otherSectionFree = freeSpace(c, otherSection);

            let candidateFree = 0;
            let candidateSection = section;

            if (preferSameSection) {
              // prioritise same section
              if (sameSectionFree <= 0) return;
              candidateFree = sameSectionFree;
              candidateSection = section;
            } else {
              // allow other section if same is unavailable
              if (sameSectionFree > 0) {
                candidateFree = sameSectionFree;
                candidateSection = section;
              } else if (otherSectionFree > 0) {
                candidateFree = otherSectionFree;
                candidateSection = otherSection;
              } else {
                return;
              }
            }

            if (candidateFree <= 0) return;
            const willUse = Math.min(remaining, candidateFree);
            const freeAfter = candidateFree - willUse;

            if (freeAfter < bestFreeAfter) {
              bestFreeAfter = freeAfter;
              best = { receiver: c, section: candidateSection, amount: willUse };
            }
          });

          if (!best) break;

          const { receiver, section: recvSection, amount } = best;

          // Apply move
          if (recvSection === "ambient") {
            receiver.ambientTotes += amount;
          } else {
            receiver.chillTotes += amount;
          }

          if (section === "ambient") {
            from.ambientTotes -= amount;
          } else {
            from.chillTotes -= amount;
          }

          remaining -= amount;
          movedSomething = true;

          moves.push({
            fromId: from.id,
            toId: receiver.id,
            section: section,
            amount
          });
        }

        return movedSomething;
      };

      // First: only same section
      let moved = tryMove(true);

      // Second: if still remaining, allow other section
      if (remaining > 0) {
        const moved2 = tryMove(false);
        moved = moved || moved2;
      }

      return moved;
    };

    const movedAmbient = moveSection("ambient");
    const movedChill = moveSection("chill");

    // If from consignment is empty after moves, remove it
    if (from.ambientTotes === 0 && from.chillTotes === 0) {
      list = list.filter((c) => c.id !== from.id);
      changed = true;
    } else if (movedAmbient || movedChill) {
      changed = true;
    } else {
      // Could not move anything from the lightest consignment;
      // stop to avoid infinite loop.
      break;
    }
  }

  // Filter out any consignment that ended up empty, even if list <= 9
  list = list.filter(
    (c) => c.ambientTotes > 0 || c.chillTotes > 0
  );

  // Ensure maximum 9 results
  if (list.length > 9) {
    // Keep the 9 heaviest (you can change this rule)
    list.sort((a, b) => {
      const loadA = a.ambientTotes + a.chillTotes;
      const loadB = b.ambientTotes + b.chillTotes;
      return loadB - loadA;
    });
    list = list.slice(0, 9);
  }

  return { consignments: list, moves };
}
